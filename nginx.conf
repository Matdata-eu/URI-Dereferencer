# Content negotiation for entity URI dereferencing
# Routes RDF-aware clients to SPARQL endpoint, browsers to SPA
map $http_accept $entity_format {
    default                          "html";
    "~*application/rdf\+xml"         "rdf";
    "~*text/turtle"                  "rdf";
    "~*application/n-triples"        "rdf";
    "~*application/ld\+json"         "rdf";
    "~*application/n-quads"          "rdf";
    "~*application/trig"             "rdf";
}

server {
    listen 8080;
    server_name _;

    root /usr/share/nginx/html;
    index index.html;

    # CORS headers
    add_header Access-Control-Allow-Origin * always;
    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS' always;
    add_header Access-Control-Allow-Headers 'Accept, Content-Type' always;

    # Static assets
    location /assets/ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # Vendor libraries
    location /vendor/ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # Health check
    location /health {
        access_log off;
        return 200 "OK\n";
        add_header Content-Type text/plain;
    }

    # Prevent stale service worker issues
    location = /sw.js {
        return 404;
    }

    # Internal: proxy DESCRIBE to SPARQL endpoint for RDF content negotiation
    location /internal/describe {
        internal;

        proxy_pass ${SPARQL_ENDPOINT};
        proxy_method POST;
        proxy_set_header Content-Type "application/sparql-query";
        proxy_set_header Accept $http_accept;
        proxy_set_body $sparql_query;
        proxy_ssl_server_name on;
    }

    # Default: content negotiation + SPA fallback
    location / {
        set $entity_uri "${BASE_URI}$uri";
        set $sparql_query "DESCRIBE <$entity_uri>";

        if ($entity_format = "rdf") {
            rewrite ^ /internal/describe last;
        }

        try_files $uri /index.html;
    }
}
